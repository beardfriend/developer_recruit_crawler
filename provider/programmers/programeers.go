package programmers

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"sync"

	"dev_recruitment_crawler/model"
)

type Programmers struct{}

func NewProgrammers() *Programmers {
	return &Programmers{}
}

const baseUrl = "https://career.programmers.co.kr/api/job_positions"

// 1&order=recent&page=1&job_category_ids[]
func (j *Programmers) jobCodeName(name string) int {
	switch name {
	case "backend":
		return 1
	case "frontend":
		return 4
	case "dataEngineer":
		return 12
	default:
		return 0
	}
}

// Generated by https://quicktype.io

type response struct {
	JobPositions               []JobPositiontion `json:"jobPositions"`
	JobPositionRecommendations []JobPositiontion `json:"jobPositionRecommendations"`
	FilterParams               FilterParams      `json:"filterParams"`
	JobPositionFilter          interface{}       `json:"jobPositionFilter"`
	Page                       int64             `json:"page"`
	TotalPages                 int64             `json:"totalPages"`
	TotalEntries               int64             `json:"totalEntries"`
	Companies                  []interface{}     `json:"companies"`
	Tags                       []interface{}     `json:"tags"`
}

type FilterParams struct {
	Locations      []interface{} `json:"locations"`
	CompanyIDS     []interface{} `json:"company_ids"`
	Tags           []interface{} `json:"tags"`
	JobCategoryIDS []interface{} `json:"job_category_ids"`
	JobThemeIDS    []interface{} `json:"job_theme_ids"`
}

type JobPositiontion struct {
	ID                int64          `json:"id"`
	Address           string         `json:"address"`
	Career            string         `json:"career"`
	CareerRange       *string        `json:"careerRange"`
	CompanyID         int64          `json:"companyId"`
	JobType           string         `json:"jobType"`
	MaxSalary         *int64         `json:"maxSalary"`
	MinSalary         *int64         `json:"minSalary"`
	Personalized      *bool          `json:"personalized"`
	SigningBonus      int64          `json:"signingBonus"`
	Status            string         `json:"status"`
	Title             string         `json:"title"`
	StartAt           string         `json:"startAt"`
	CreatedAt         string         `json:"createdAt"`
	UpdatedAt         string         `json:"updatedAt"`
	CareerOption      bool           `json:"careerOption"`
	JobCategoryIDS    []int64        `json:"jobCategoryIds"`
	Period            string         `json:"period"`
	TechnicalTags     []TechnicalTag `json:"technicalTags"`
	TeamTechnicalTags []string       `json:"teamTechnicalTags"`
	URL               string         `json:"url"`
	IsBookmarked      bool           `json:"isBookmarked"`
	Company           Company        `json:"company"`
}

type Company struct {
	ID                  int64       `json:"id"`
	Name                string      `json:"name"`
	Address             string      `json:"address"`
	ServiceName         string      `json:"serviceName"`
	ServiceURL          string      `json:"serviceUrl"`
	HomeURL             string      `json:"homeUrl"`
	Funding             int64       `json:"funding"`
	HideFunding         bool        `json:"hideFunding"`
	Revenue             float64     `json:"revenue"`
	HideRevenue         bool        `json:"hideRevenue"`
	Blog                *string     `json:"blog"`
	CountryCode         string      `json:"countryCode"`
	AverageResponseTime *string     `json:"averageResponseTime"`
	EmployeesCount      int64       `json:"employeesCount"`
	LogoURL             string      `json:"logoUrl"`
	Developers          []Developer `json:"developers"`
}

type Developer struct {
	URL         string `json:"url"`
	Icon        string `json:"icon"`
	Name        string `json:"name"`
	Description string `json:"description"`
}

type TechnicalTag struct {
	ID            int64  `json:"id"`
	Name          string `json:"name"`
	TaggingsCount int64  `json:"taggings_count"`
	Category      string `json:"category"`
	Approved      bool   `json:"approved"`
	DisplayOrder  int64  `json:"display_order"`
}

func (j *Programmers) GetRecruitment(minCareer int, job string) []*model.Recruitment {
	resp := j.get(minCareer, job, 1)
	response := make([]*model.Recruitment, 0)
	response = j.addResponse(resp.JobPositions, response)

	var wg sync.WaitGroup
	for i := 2; i < int(resp.TotalPages); i++ {
		wg.Add(1)
		go func(i int) {
			defer wg.Done()
			resp := j.get(minCareer, job, i)
			response = j.addResponse(resp.JobPositions, response)
		}(i)
	}
	wg.Wait()

	return response
}

func (j *Programmers) addResponse(data []JobPositiontion, response []*model.Recruitment) []*model.Recruitment {
	for _, v := range data {
		response = append(response, &model.Recruitment{
			Title:       v.Title,
			Provider:    "programmers",
			Url:         fmt.Sprintf("https://career.programmers.co.kr/job_positions/%d", v.ID),
			CompanyName: v.Company.Name,
			Location:    v.Company.Address,
			ImageUrl:    v.Company.LogoURL,
		})
	}

	return response
}

func (j *Programmers) get(minCareer int, job string, pageNo int) *response {
	req, _ := http.NewRequest(http.MethodGet, baseUrl, nil)
	query := req.URL.Query()
	query.Add("job_category_ids[]", fmt.Sprint(j.jobCodeName(job)))
	query.Add("page", fmt.Sprint(pageNo))
	query.Add("min_career", fmt.Sprint(minCareer))
	req.URL.RawQuery = query.Encode()

	c := http.Client{}
	resp, err := c.Do(req)
	if err != nil {
		log.Fatal(err)
	}
	defer resp.Body.Close()

	data, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		log.Fatal(err)
	}

	result := new(response)
	json.Unmarshal(data, result)

	return result
}
